#!/usr/bin/env bash
set -euo pipefail
HERE="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

HOSTS_FILE="${HOSTS_FILE:-$HERE/hosts.txt}"
API_PORT="${API_PORT:-4068}"

if [[ ! -f "$HOSTS_FILE" ]]; then
  echo "Missing hosts file: $HOSTS_FILE" >&2
  exit 1
fi

# Each line: host or host:port
HOSTS="$(grep -vE '^[[:space:]]*#' "$HOSTS_FILE" | tr -d '' | awk 'NF{print $0}')"

rows=()

for h in $HOSTS; do
  host="$h"; port="$API_PORT"
  if [[ "$h" == *:* ]]; then
    host="${h%%:*}"; port="${h##*:}"
  fi

  # ccminer API is raw TCP; use api.pl
  if [[ ! -x "$HERE/api.pl" ]]; then
    echo "Missing $HERE/api.pl (chmod +x?)" >&2
    exit 1
  fi

  out="$("$HERE/api.pl" --cmd summary --address "$host" --port "$port" 2>/dev/null || true)"
  if [[ -z "$out" || "$out" == *"No Connection"* ]]; then
    rows+=("$(jq -n --arg host "$host" '{HOST:$host,ONLINE:false}')")
    continue
  fi

  # Convert: KEY=VAL;KEY2=VAL2;|KEY3=VAL3; ... into JSON-ish
  # keep only first record before |
  first="${out%%|*}"
  # split by ; into key=val pairs
  json="$(jq -n --arg host "$host" '
    {HOST:$host,ONLINE:true}
  ')"

  IFS=';' read -r -a parts <<< "$first"
  for kv in "${parts[@]}"; do
    [[ -z "$kv" ]] && continue
    key="${kv%%=*}"
    val="${kv#*=}"
    # normalize key
    key="$(echo "$key" | tr -cd 'A-Za-z0-9_')"
    # attempt numeric
    if [[ "$val" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
      json="$(echo "$json" | jq --arg k "$key" --arg v "$val" '. + {($k): ($v|tonumber)}')"
    else
      json="$(echo "$json" | jq --arg k "$key" --arg v "$val" '. + {($k): $v}')"
    fi
  done

  rows+=("$json")
done

printf '%s
' "${rows[@]}" | jq -s 'map({
  HOST,
  ONLINE,
  POOL: (.POOL // ""),
  USER: (.USER // ""),
  KHS: (.KHS // 0),
  ACC: (.ACC // 0),
  REJ: (.REJ // 0),
  WAIT: (.WAIT // 0),
  UPTIME: (.UPTIME // "")
}) | sort_by(.HOST)'
